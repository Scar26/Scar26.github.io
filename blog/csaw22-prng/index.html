<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content><meta name=description content="This is a writeup of the cryptography task &amp;ldquo;Master of PRNG&amp;rdquo; from the CSAW finals 2022. It had around 6 solves by the end of the CTF.
The first part of this challenge involves generalizing the classic Hidden Number Problem to a case with 2 constants, followed by the usual CVP. The second part additionally involves a simple but subtle observation regarding the public moduli.
The challenge file can be found here: chall."><meta name=keywords content><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=http://scar26.github.io/blog/csaw22-prng/><title>CSAW22 - Attacking a Linear PRNG with LLL :: Bits and Packets â€” Scar's blog on Security and Cryptography</title><link href=https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css rel=stylesheet type=text/css><link rel=stylesheet href=/main.55601fb9ba6973aabbae15a6ed0e4e331634f50c5cca6bd2e26df91da88d43ff.css><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color><link rel="shortcut icon" href=/favicon.ico><meta name=msapplication-TileColor content><meta itemprop=name content="CSAW22 - Attacking a Linear PRNG with LLL"><meta itemprop=description content="This is a writeup of the cryptography task &ldquo;Master of PRNG&rdquo; from the CSAW finals 2022. It had around 6 solves by the end of the CTF.
The first part of this challenge involves generalizing the classic Hidden Number Problem to a case with 2 constants, followed by the usual CVP. The second part additionally involves a simple but subtle observation regarding the public moduli.
The challenge file can be found here: chall."><meta itemprop=datePublished content="2022-11-16T18:37:48+05:30"><meta itemprop=dateModified content="2022-11-16T18:37:48+05:30"><meta itemprop=wordCount content="1571"><meta itemprop=image content="http://scar26.github.io/"><meta itemprop=keywords content><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://scar26.github.io/"><meta name=twitter:title content="CSAW22 - Attacking a Linear PRNG with LLL"><meta name=twitter:description content="This is a writeup of the cryptography task &ldquo;Master of PRNG&rdquo; from the CSAW finals 2022. It had around 6 solves by the end of the CTF.
The first part of this challenge involves generalizing the classic Hidden Number Problem to a case with 2 constants, followed by the usual CVP. The second part additionally involves a simple but subtle observation regarding the public moduli.
The challenge file can be found here: chall."><meta property="og:title" content="CSAW22 - Attacking a Linear PRNG with LLL"><meta property="og:description" content="This is a writeup of the cryptography task &ldquo;Master of PRNG&rdquo; from the CSAW finals 2022. It had around 6 solves by the end of the CTF.
The first part of this challenge involves generalizing the classic Hidden Number Problem to a case with 2 constants, followed by the usual CVP. The second part additionally involves a simple but subtle observation regarding the public moduli.
The challenge file can be found here: chall."><meta property="og:type" content="article"><meta property="og:url" content="http://scar26.github.io/blog/csaw22-prng/"><meta property="og:image" content="http://scar26.github.io/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2022-11-16T18:37:48+05:30"><meta property="article:modified_time" content="2022-11-16T18:37:48+05:30"><meta property="og:site_name" content="Bits and Packets"><meta property="article:published_time" content="2022-11-16 18:37:48 +0530 +0530"></head><body><div class=container><header class=header><span class=header__inner><a href=/ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>Bits And Packets</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=/about>About</a></li><li><a href=/blog>Blog</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info></p></div><article><h2 class=post-title><a href=http://scar26.github.io/blog/csaw22-prng/>CSAW22 - Attacking a Linear PRNG with LLL</a></h2><div class=post-content><p>This is a writeup of the cryptography task &ldquo;Master of PRNG&rdquo; from the CSAW finals 2022. It had around 6 solves by the end of the CTF.</p><p>The first part of this challenge involves generalizing the classic Hidden Number Problem to a case with 2 constants, followed by the usual CVP. The second part additionally involves a simple but subtle observation regarding the public moduli.</p><p>The challenge file can be found here: <a href=/assets/csaw22/csaw22-prng-chall.py>chall.py</a></p><h2 id=challenge-summary>Challenge Summary</h2><p>Let $n_1, n_2$ be 512 bit prime moduli</p><p>$a_1, a_2 \in Z_{n_1}$ and $b_1, b_2 \in Z_{n_2}$ are randomly generated coefficients.</p><p>In summary, We have a PRNG scheme seeded with $0 \leq x_0, x_1, y_0, y_1 \leq n_2$ where</p><p>$$x_i \equiv a_1x_{i-1} + a_2x_{i-2}\ mod\ n_1$$
$$y_i \equiv b_1y_{i-1} + b_2y_{i-2}\ mod\ n_2$$
$$z_i \equiv x_i - y_i\ mod\ n_1$$</p><p>$a_1, a_2, b_1, b_2, n_1, n_2$ are public parameters</p><p>We&rsquo;re given $x_i$ && $2^{307}, z_i$ &#187; $204$ &#171; $204\ |\ 2 \leq i \leq 6$ and need to predict $y_7$ for the flag.</p><p>Given $x_i$ and $z_i$, the challenge would be trivial since we could easily recover $y_i\ 2 \leq i \leq 6$ and use it to predict $y_7$. The problem is, the upper 204 bits for x and lower 204 bits for z have been masked out.</p><p>Essentially, we&rsquo;re missing the upper ~204 bits for $x_i$ and the lower ~204 bits for $z_i$ ($x_i, z_i$ ~ 512 bits so we&rsquo;re missing around 40% of the bits)</p><h2 id=solution>Solution</h2><p>Examining, the equations for $x_i$</p><p>For $2 \leq i \leq 6$, we have,
$$x_i \equiv a1_ix_{1} + a2_ix_{0}\ mod\ n_1$$
Where $a1_i, a2_i$ can be computed from $a_{1}, a_{2}$</p><p>For example,
$$x_2 \equiv a_1x_{1} + a_2x_{0}\ mod\ n_1$$
$$x_3 \equiv a_1x_{2} + a_2x_{1} = (a_1^2 + a_2)x_1 + a_1a_2x_0 \ mod\ n_1$$</p><p>This can be re-written as
$$2^{307}ux_i + lx_i \equiv a1_ix_{1} + a2_ix_{0}\ mod\ n_1$$
Where $lx_i$ are the lower 307 bits (known) and $ux_i$ are the remaining upper bits (unknown)</p><p>Multiplying by $2^{-307}$, we end up with an equation of the form</p><p>$$ux_i + c_i \equiv a1_ix_{1} + a2_ix_{0}\ mod\ n_1$$</p><p>We have 5 such equations and wish to recover $ux_{i}$, where $ux_{i}$ is relatively small (0.4 * the bitlength of $n_1$).</p><p>On a closer look, this looks really similar to the Hidden Number Problem, used in biased nonce attacks against Elliptic Curves. In HNP, we have a set of m equations</p><p>$$x_i + a_i \equiv t_iy\ mod\ p\ 0 \leq i \leq m$$ where y is an unknown constant and the $x_i$, which we wish to recover are small. The difference is that we have 2 constants ($x_0, x_1$) instead of a single y. To extend HNP to our case, we must understand the intuition behind how it&rsquo;s reduced to lattice CVP.</p><p>Let <strong>X</strong> be the vector of $x_i$</p><p><strong>A</strong> be the vector of $a_i$</p><p><strong>T</strong> be the vector of $t_i$</p><p><strong>$P_i$</strong> be a vector with p in the ith index and 0 everywhere else</p><p>Our set of equations can be represented in vector form as</p><p><strong>X</strong> + <strong>A</strong> = <strong>T</strong>*y - $\sum_{i\ =\ 0}^{n} k_{i}$$P_{i}$</p><p>Since y and $k_i$ are all integers, <strong>X</strong> + <strong>A</strong> lies in the lattice $L$ spanned by the basis (<strong>T</strong>, <strong>$P_0$</strong>, <strong>$P_1$</strong> &mldr; <strong>$P_n$</strong>)</p><p>Since <strong>X</strong> is small, if we look for the vector in $L$ closest to <strong>A</strong>, we can recover <strong>X</strong> with high probability. There are certain limitations (check minkowski&rsquo;s theorem) but intuitively, this is how it works. Extrapolating from this to our equations</p><p>$$ux_i + c_i \equiv a1_ix_{1} + a2_ix_{0}\ mod\ n_1\ = a1_ix_{1} + a2_ix_{0} - k_in_1$$</p><p><strong>X</strong> + <strong>C</strong> = <strong>A1</strong>$x_1$ + <strong>A2</strong>$x_0$ - $\sum_{i\ =\ 0}^{n} k_{i}$$P_{i}$</p><p>Where
<strong>X</strong> is the vector of $ux_i$
<strong>C</strong> is the vector of $c_i$
<strong>A1</strong> is the vector of $a1_i$
<strong>A2</strong> is the vector of $a2_i$</p><p>so <strong>X</strong> + <strong>A</strong> lies in the lattice
$$L\ =\ \left[\begin{matrix}
n_1 & 0 & 0 & 0 & 0 \newline
0 & n_1 & 0 & 0 & 0 \newline
0 & 0 & n_1 & 0 & 0 \newline
0 & 0 & 0 & n_1 & 0 \newline
0 & 0 & 0 & 0 & n_1 \newline
a1_{2} & a1_{3} & a1_{4} & a1_{5} & a1_{6}\newline
a2_{2} & a2_{3} & a2_{4} & a2_{5} & a2_{6}
\end{matrix}\right]$$</p><p>Thus, $$X\ =\ CVP(L, A) - A$$</p><p>GG, we have successfully recovered all $x_i$.
Here&rsquo;s the sage code I wrote for this</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>solve_cvp_1</span>(B, t):
</span></span><span style=display:flex><span>    t_ <span style=color:#f92672>=</span> t <span style=color:#f92672>-</span> B<span style=color:#f92672>.</span>stack(t)<span style=color:#f92672>.</span>gram_schmidt()[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>.</span>row(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    B_ <span style=color:#f92672>=</span> B<span style=color:#f92672>.</span>LLL()
</span></span><span style=display:flex><span>    c <span style=color:#f92672>=</span> B_<span style=color:#f92672>.</span>solve_left(t_)
</span></span><span style=display:flex><span>    c_ <span style=color:#f92672>=</span> vector(map(round, c))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> c_ <span style=color:#f92672>*</span> B_
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>coeffsx <span style=color:#f92672>=</span> [(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>), (<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>5</span>):
</span></span><span style=display:flex><span>    coeffsx<span style=color:#f92672>.</span>append((coeffsx[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>]<span style=color:#f92672>*</span>a_1 <span style=color:#f92672>+</span> coeffsx[<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>0</span>]<span style=color:#f92672>*</span>a_2, coeffsx[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>]<span style=color:#f92672>*</span>a_1 <span style=color:#f92672>+</span> coeffsx[<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>1</span>]<span style=color:#f92672>*</span>a_2))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>coeffsx <span style=color:#f92672>=</span> coeffsx[<span style=color:#ae81ff>2</span>:]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mat <span style=color:#f92672>=</span> [[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>*</span><span style=color:#ae81ff>5</span> <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>7</span>)]
</span></span><span style=display:flex><span>v <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>]<span style=color:#f92672>*</span><span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sf <span style=color:#f92672>=</span>  (<span style=color:#ae81ff>2</span> <span style=color:#f92672>**</span> <span style=color:#ae81ff>307</span>)
</span></span><span style=display:flex><span>si <span style=color:#f92672>=</span> Integer(Mod(sf, n1)<span style=color:#f92672>^-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>5</span>):
</span></span><span style=display:flex><span>    mat[i][i] <span style=color:#f92672>=</span> n1
</span></span><span style=display:flex><span>    mat[<span style=color:#ae81ff>5</span>][i] <span style=color:#f92672>=</span> si<span style=color:#f92672>*</span>coeffsx[i][<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>    mat[<span style=color:#ae81ff>6</span>][i] <span style=color:#f92672>=</span> si<span style=color:#f92672>*</span>coeffsx[i][<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    v[i] <span style=color:#f92672>=</span> si<span style=color:#f92672>*</span>ret_xs[i]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mat <span style=color:#f92672>=</span> Matrix(ZZ, mat)
</span></span><span style=display:flex><span>v <span style=color:#f92672>=</span> vector(ZZ, v)
</span></span><span style=display:flex><span>t <span style=color:#f92672>=</span> solve_cvp(mat, v)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>x2 <span style=color:#f92672>=</span> (sf<span style=color:#f92672>*</span>(t<span style=color:#f92672>-</span>v)[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>+</span> ret_xs[<span style=color:#ae81ff>0</span>])<span style=color:#f92672>%</span>n1
</span></span><span style=display:flex><span>x3 <span style=color:#f92672>=</span> (sf<span style=color:#f92672>*</span>(t<span style=color:#f92672>-</span>v)[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> ret_xs[<span style=color:#ae81ff>1</span>])<span style=color:#f92672>%</span>n1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>x_state <span style=color:#f92672>=</span> [x2, x3]
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>3</span>):
</span></span><span style=display:flex><span>    x_state<span style=color:#f92672>.</span>append((a_1<span style=color:#f92672>*</span>x_state[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> a_2<span style=color:#f92672>*</span>x_state[<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>])<span style=color:#f92672>%</span>n1)
</span></span></code></pre></div><p>Now for $z_i$, rewriting the equation for $y_i$ in as similar way as $x_i$, we get</p><p>$$z_i \equiv x_i - y_i\ mod\ n_1$$
$$uz_i + lz_i \equiv x_i - (b1_iy_1 + b2_iy_0\ mod\ n_2)\ mod\ n_1$$
$$uz_i + lz_i = x_i - (b1_iy_1 + b2_iy_0\ - k1_in_2)\ - k2_in_1$$</p><p>We now know $x_i$ and wish to recover $lz_i$, but the double mod poses a problem. We can&rsquo;t have both $n_1$ and $n_2$ in the lattice basis as they are coprime and would just cancel out any other values, giving a rank 0 basis.</p><p>I was stuck on this part for a while. One of the things I noticed was $n_2 &lt; n_1$, meaning $y_0\ mod\ n_1 = y_0, y_1\ mod\ n_1 = y_1$. So I spent a lot of time trying to homogenize the entire equation to $Z_(n_1n_2)$ with CRT but it didn&rsquo;t work out. Then I got hit with the stupidly simple observation that had been staring me in the face in the entire time.</p><p>Given $n_1 > n_2$,
$$x_i = O(n_1), y_i ~ O(n_2) \implies x_i - y_i = O(n_1)$$
Meaning $k2_i$ is small! Infact, practically, $k2_i \in {-1, 0, 1}$</p><p>Let&rsquo;s say we know the values for all $k2_i$ (since we can just bruteforce the $3^5$ possibilities), we end up with the system of equations</p><p>$$b1_iy_1 + b2_iy_0 - k1_in_2 = c_i - lz_i$$
where $c_i = x_i - k2_in_1 - uz_i$</p><p>So $C - LZ$ lies in the lattice</p><p>$$L\ =\ \left[\begin{matrix}
n_2 & 0 & 0 & 0 & 0 \newline
0 & n_2 & 0 & 0 & 0 \newline
0 & 0 & n_2 & 0 & 0 \newline
0 & 0 & 0 & n_2 & 0 \newline
0 & 0 & 0 & 0 & n_2 \newline
b1_{2} & b1_{3} & b1_{4} & b1_{5} & b1_{6}\newline
b2_{2} & b2_{3} & b2_{4} & b2_{5} & b2_{6}
\end{matrix}\right]$$</p><p>$$V = \left[c_2 - lz_2\ c_3 - lz_3\ c_4 - lz_4\ c_5 - lz_5\ c_6 - lz_6\ \right]^T \in L$$
$$C - V = LZ$$</p><p>Since LZ is small, we have</p><p>$$LZ = C - CVP(L, V)$$</p><p>Iterating over all $3^5$ possibilities of C (by varying $k2_i \in {-1, 0, 1}$) we can identify the correct <strong>LZ</strong> as the one where
all values have the expected bitlength (~205)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>xv <span style=color:#f92672>=</span> vector(ZZ, x_state)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mat <span style=color:#f92672>=</span> [[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>*</span><span style=color:#ae81ff>5</span> <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>7</span>)]
</span></span><span style=display:flex><span>v <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>]<span style=color:#f92672>*</span><span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>5</span>):
</span></span><span style=display:flex><span>    mat[i][i] <span style=color:#f92672>=</span> n2
</span></span><span style=display:flex><span>    mat[<span style=color:#ae81ff>5</span>][i] <span style=color:#f92672>=</span> coeffsy[i][<span style=color:#ae81ff>0</span>]<span style=color:#f92672>%</span>n2
</span></span><span style=display:flex><span>    mat[<span style=color:#ae81ff>6</span>][i] <span style=color:#f92672>=</span> coeffsy[i][<span style=color:#ae81ff>1</span>]<span style=color:#f92672>%</span>n2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mat <span style=color:#f92672>=</span> Matrix(ZZ, mat)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>z <span style=color:#f92672>=</span> [<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>dels <span style=color:#f92672>=</span> list(map(<span style=color:#66d9ef>lambda</span> x: vector(ZZ, list(x)), list(itertools<span style=color:#f92672>.</span>product(z, repeat<span style=color:#f92672>=</span><span style=color:#ae81ff>5</span>))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> d <span style=color:#f92672>in</span> dels:
</span></span><span style=display:flex><span>    v <span style=color:#f92672>=</span> xv <span style=color:#f92672>-</span> vector(ZZ, ret_zs) <span style=color:#f92672>-</span> d<span style=color:#f92672>*</span>n1
</span></span><span style=display:flex><span>    t <span style=color:#f92672>=</span> solve_cvp(mat, v)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> max(v <span style=color:#f92672>-</span> t)<span style=color:#f92672>.</span>nbits() <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>250</span>:
</span></span><span style=display:flex><span>        y_state <span style=color:#f92672>=</span> list(t)
</span></span><span style=display:flex><span>        k <span style=color:#f92672>=</span> (b_1<span style=color:#f92672>*</span>y_state[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> b_2<span style=color:#f92672>*</span>y_state[<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>])<span style=color:#f92672>%</span>n2
</span></span><span style=display:flex><span>        print (<span style=color:#e6db74>&#34;y_7 = &#34;</span>, k)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>
</span></span></code></pre></div><p><code>flag{_w0w_y0u_@r3_s0_g00d_@_L4t7ice_}</code></p><h2 id=complete-code>Complete Code</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> Crypto.Util.number <span style=color:#f92672>import</span> long_to_bytes, bytes_to_long
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> sage.modules.free_module_integer <span style=color:#f92672>import</span> IntegerLattice
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> itertools
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>solve_cvp</span>(mat, target):
</span></span><span style=display:flex><span>	M <span style=color:#f92672>=</span> IntegerLattice(mat, lll_reduce<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)<span style=color:#f92672>.</span>reduced_basis
</span></span><span style=display:flex><span>	G <span style=color:#f92672>=</span> M<span style=color:#f92672>.</span>gram_schmidt()[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>	diff <span style=color:#f92672>=</span> target
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> reversed(range(G<span style=color:#f92672>.</span>nrows())):
</span></span><span style=display:flex><span>		diff <span style=color:#f92672>-=</span>  M[i] <span style=color:#f92672>*</span> ((diff <span style=color:#f92672>*</span> G[i]) <span style=color:#f92672>/</span> (G[i] <span style=color:#f92672>*</span> G[i]))<span style=color:#f92672>.</span>round()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> target <span style=color:#f92672>-</span> diff
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>module_bit <span style=color:#f92672>=</span> <span style=color:#ae81ff>512</span>
</span></span><span style=display:flex><span>beta <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.6</span>
</span></span><span style=display:flex><span>a_1,a_2 <span style=color:#f92672>=</span>  [<span style=color:#ae81ff>9919754465736816172569173052425931289517829891854342593290927744542118133847348662406222547572947297178727236300405992491684375909305177189047780739423811</span>, <span style=color:#ae81ff>2558159371069956421749072997341298610563190398496109008773995596731281585562821740934514052081914548707643961639133075782257512937408016925625816701379184</span>]
</span></span><span style=display:flex><span>b_1,b_2 <span style=color:#f92672>=</span>  [<span style=color:#ae81ff>2605193676009044327751542404995552395651364785430784591434496675113980641629822868464738894812540539614357309531957125239722030117295601326651054134997855</span>, <span style=color:#ae81ff>3197045230062951998763856325415663842943082118997359612045648551897230423045976716318651375603679498159844171771317291574116847000481449039959441081514627</span>]
</span></span><span style=display:flex><span>n1 <span style=color:#f92672>=</span>  <span style=color:#ae81ff>11681289596798868397030596649789726767285990000843272211957420810019522067387532211264897471096909399295930769738569665286430964000906934541163352714344519</span>
</span></span><span style=display:flex><span>n2 <span style=color:#f92672>=</span>  <span style=color:#ae81ff>10557965421921341302784057525127038885537939006621468287750526343357317493360177624286054901157989185048184920439519551848192429179141349006037985539214071</span>
</span></span><span style=display:flex><span>ret_xs <span style=color:#f92672>=</span>  [<span style=color:#ae81ff>258466590698311071331247037930868824798600351331801120333006455557946900924072178631112955877</span>, <span style=color:#ae81ff>9821442718613283840479818314015332171481079398147839951441986495105073061641539763228587316</span>, <span style=color:#ae81ff>44840961768274714901326962447354283020302651991130253647924461474246517162698016799008370900</span>, <span style=color:#ae81ff>4181026132314144744475531197443398345060712084263169112302700944672100108051705214872237804</span>, <span style=color:#ae81ff>165146543464042899162832236414189105534540273973129205248892886798269176015886688299461120067</span>]
</span></span><span style=display:flex><span>ret_zs <span style=color:#f92672>=</span>  [<span style=color:#ae81ff>11425495409956732054927782736077190158254288269207497569801502736793464884202670506015379318738941018498330797528225268357863433326525610294847934650384384</span>, <span style=color:#ae81ff>6493331726937754866196531134748756985061780536063848814074103775547995272554729994318400024248625477632819500830464284078877134996898279637865644465061888</span>, <span style=color:#ae81ff>993089766452002806192286220960438231942075399393023941745370499613681022868865277955412695258671518735133398965459541404411563617841529593232577007714304</span>, <span style=color:#ae81ff>9947918164778455706315062500056819613968192691484842758450452417155875586535345223342626196771965216296162822961357707526761812463743778564968870859243520</span>, <span style=color:#ae81ff>6798568953150532649740005658966557905457680624368167498216858785007123058363282156005182480229608829437870473084370507240870801760529936705635869020651520</span>]      
</span></span><span style=display:flex><span>encflag <span style=color:#f92672>=</span>  <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\x84\x0b</span><span style=color:#e6db74>k</span><span style=color:#ae81ff>\xfb</span><span style=color:#e6db74>mp</span><span style=color:#ae81ff>\x1a</span><span style=color:#e6db74>V</span><span style=color:#ae81ff>\x95</span><span style=color:#e6db74>q</span><span style=color:#ae81ff>\r\x9b</span><span style=color:#e6db74>Z/s</span><span style=color:#ae81ff>\xe5\xb4\xa5</span><span style=color:#e6db74>Y~y</span><span style=color:#ae81ff>\xac\xaa\xd1\xff\xf1\xf1\xee</span><span style=color:#e6db74>#</span><span style=color:#ae81ff>\xbd\x07</span><span style=color:#e6db74>:n</span><span style=color:#ae81ff>\x9c\xd6\xcd</span><span style=color:#e6db74>V*</span><span style=color:#ae81ff>\xfc\xbe</span><span style=color:#e6db74>0</span><span style=color:#ae81ff>\x96\xff\xff\xa1</span><span style=color:#e6db74>E</span><span style=color:#ae81ff>\xdd\xb3\x96\xa2\xb2\x8c</span><span style=color:#e6db74>W</span><span style=color:#ae81ff>\xc2</span><span style=color:#e6db74>#6Y</span><span style=color:#ae81ff>\xa0\xf2\xd7\xb7</span><span style=color:#e6db74>*</span><span style=color:#ae81ff>\xbb\xfb</span><span style=color:#e6db74>&#39;</span>
</span></span><span style=display:flex><span>ct <span style=color:#f92672>=</span> bytes_to_long(encflag)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>coeffsx <span style=color:#f92672>=</span> [(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>), (<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span>coeffsy <span style=color:#f92672>=</span> [(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>), (<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>5</span>):
</span></span><span style=display:flex><span>    coeffsx<span style=color:#f92672>.</span>append((coeffsx[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>]<span style=color:#f92672>*</span>a_1 <span style=color:#f92672>+</span> coeffsx[<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>0</span>]<span style=color:#f92672>*</span>a_2, coeffsx[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>]<span style=color:#f92672>*</span>a_1 <span style=color:#f92672>+</span> coeffsx[<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>1</span>]<span style=color:#f92672>*</span>a_2))
</span></span><span style=display:flex><span>    coeffsy<span style=color:#f92672>.</span>append((coeffsy[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>0</span>]<span style=color:#f92672>*</span>b_1 <span style=color:#f92672>+</span> coeffsy[<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>0</span>]<span style=color:#f92672>*</span>b_2, coeffsy[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][<span style=color:#ae81ff>1</span>]<span style=color:#f92672>*</span>b_1 <span style=color:#f92672>+</span> coeffsy[<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>1</span>]<span style=color:#f92672>*</span>b_2))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>coeffsx <span style=color:#f92672>=</span> coeffsx[<span style=color:#ae81ff>2</span>:]
</span></span><span style=display:flex><span>coeffsy <span style=color:#f92672>=</span> coeffsy[<span style=color:#ae81ff>2</span>:]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mat <span style=color:#f92672>=</span> [[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>*</span><span style=color:#ae81ff>5</span> <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>7</span>)]
</span></span><span style=display:flex><span>v <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>]<span style=color:#f92672>*</span><span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sf <span style=color:#f92672>=</span>  (<span style=color:#ae81ff>2</span> <span style=color:#f92672>**</span> int(module_bit <span style=color:#f92672>*</span> beta))
</span></span><span style=display:flex><span>si <span style=color:#f92672>=</span> Integer(Mod(sf, n1)<span style=color:#f92672>^-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>5</span>):
</span></span><span style=display:flex><span>    mat[i][i] <span style=color:#f92672>=</span> n1
</span></span><span style=display:flex><span>    mat[<span style=color:#ae81ff>5</span>][i] <span style=color:#f92672>=</span> si<span style=color:#f92672>*</span>coeffsx[i][<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>    mat[<span style=color:#ae81ff>6</span>][i] <span style=color:#f92672>=</span> si<span style=color:#f92672>*</span>coeffsx[i][<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    v[i] <span style=color:#f92672>=</span> si<span style=color:#f92672>*</span>ret_xs[i]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mat <span style=color:#f92672>=</span> Matrix(ZZ, mat)
</span></span><span style=display:flex><span>v <span style=color:#f92672>=</span> vector(ZZ, v)
</span></span><span style=display:flex><span>t <span style=color:#f92672>=</span> solve_cvp(mat, v)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>x2 <span style=color:#f92672>=</span> (sf<span style=color:#f92672>*</span>(t<span style=color:#f92672>-</span>v)[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>+</span> ret_xs[<span style=color:#ae81ff>0</span>])<span style=color:#f92672>%</span>n1
</span></span><span style=display:flex><span>x3 <span style=color:#f92672>=</span> (sf<span style=color:#f92672>*</span>(t<span style=color:#f92672>-</span>v)[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> ret_xs[<span style=color:#ae81ff>1</span>])<span style=color:#f92672>%</span>n1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>x_state <span style=color:#f92672>=</span> [x2, x3]
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>3</span>):
</span></span><span style=display:flex><span>    x_state<span style=color:#f92672>.</span>append((a_1<span style=color:#f92672>*</span>x_state[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> a_2<span style=color:#f92672>*</span>x_state[<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>])<span style=color:#f92672>%</span>n1)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>xv <span style=color:#f92672>=</span> vector(ZZ, x_state)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mat <span style=color:#f92672>=</span> [[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>*</span><span style=color:#ae81ff>5</span> <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>7</span>)]
</span></span><span style=display:flex><span>v <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>]<span style=color:#f92672>*</span><span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>5</span>):
</span></span><span style=display:flex><span>    mat[i][i] <span style=color:#f92672>=</span> n2
</span></span><span style=display:flex><span>    mat[<span style=color:#ae81ff>5</span>][i] <span style=color:#f92672>=</span> coeffsy[i][<span style=color:#ae81ff>0</span>]<span style=color:#f92672>%</span>n2
</span></span><span style=display:flex><span>    mat[<span style=color:#ae81ff>6</span>][i] <span style=color:#f92672>=</span> coeffsy[i][<span style=color:#ae81ff>1</span>]<span style=color:#f92672>%</span>n2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mat <span style=color:#f92672>=</span> Matrix(ZZ, mat)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>z <span style=color:#f92672>=</span> [<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>dels <span style=color:#f92672>=</span> list(map(<span style=color:#66d9ef>lambda</span> x: vector(ZZ, list(x)), list(itertools<span style=color:#f92672>.</span>product(z, repeat<span style=color:#f92672>=</span><span style=color:#ae81ff>5</span>))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> d <span style=color:#f92672>in</span> dels:
</span></span><span style=display:flex><span>    v <span style=color:#f92672>=</span> xv <span style=color:#f92672>-</span> vector(ZZ, ret_zs) <span style=color:#f92672>-</span> d<span style=color:#f92672>*</span>n1
</span></span><span style=display:flex><span>    t <span style=color:#f92672>=</span> solve_cvp(mat, v)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> max(v <span style=color:#f92672>-</span> t)<span style=color:#f92672>.</span>nbits() <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>250</span>:
</span></span><span style=display:flex><span>        y_state <span style=color:#f92672>=</span> list(t)
</span></span><span style=display:flex><span>        k <span style=color:#f92672>=</span> (b_1<span style=color:#f92672>*</span>y_state[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> b_2<span style=color:#f92672>*</span>y_state[<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>])<span style=color:#f92672>%</span>n2
</span></span><span style=display:flex><span>        print (long_to_bytes(ct<span style=color:#f92672>^^</span>k))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>
</span></span></code></pre></div></div></article><hr><div class=post-info></div></main></div><footer class=footer></footer></div><script type=text/javascript src=/bundle.min.bb2c6bc3ed452ca4759660e4020811f248bc2320081559e8a32d8b0092773852941133639d35e8370d03d3ddaa750b1edd6b343c5bd22a55d5bdeae8f648f49b.js integrity="sha512-uyxrw+1FLKR1lmDkAggR8ki8IyAIFVnooy2LAJJ3OFKUETNjnTXoNw0D092qdQse3Ws0PFvSKlXVvero9kj0mw=="></script></body></html>